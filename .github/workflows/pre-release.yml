name: prerelease-on-stage

on:
  push:
    branches: ["stage"]

permissions:
  contents: write
  pull-requests: read

jobs:
  pre-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute next prerelease tag (vX.Y.Z-stage.N) from PR labels
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          LAST="$(git tag --list 'v*.*.*' --sort=-creatordate | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1 || true)"
          if [ -z "$LAST" ]; then
            LAST="v0.0.0"
          fi

          LAST_PUBLISHED_AT="$(gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${LAST}" --jq '.published_at' 2>/dev/null || true)"
          if [ -z "${LAST_PUBLISHED_AT:-}" ] || [ "${LAST_PUBLISHED_AT}" = "null" ]; then
            # If LAST is not a real tag yet, fall back to an "old" timestamp so we include everything.
            LAST_PUBLISHED_AT="$(git log -1 --format=%cI "${LAST}" 2>/dev/null || true)"
          fi
          if [ -z "${LAST_PUBLISHED_AT:-}" ]; then
            LAST_PUBLISHED_AT="1970-01-01T00:00:00Z"
          fi

          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"

          gh api graphql -f query='
            query($owner:String!, $name:String!) {
              repository(owner:$owner, name:$name) {
                pullRequests(first:100, states:MERGED, orderBy:{field:UPDATED_AT, direction:DESC}) {
                  nodes {
                    number
                    title
                    url
                    mergedAt
                    baseRefName
                    labels(first:50) { nodes { name } }
                  }
                }
              }
            }' -f owner="$OWNER" -f name="$REPO" > prs.json

          # PRs merged into stage since last stable release
          jq -c --arg since "$LAST_PUBLISHED_AT" '
            .data.repository.pullRequests.nodes
            | map(select(.baseRefName == "stage"))
            | map(select(.mergedAt != null and .mergedAt > $since))
          ' prs.json > prs_since.json

          HAS_REMOVED="$(jq '[.[].labels.nodes[].name] | any(. == "removed")' prs_since.json)"
          HAS_FEATURE="$(jq '[.[].labels.nodes[].name] | any(. == "feature")' prs_since.json)"
          HAS_PATCH="$(jq '[.[].labels.nodes[].name] | any(. == "bug" or . == "security" or . == "documentation")' prs_since.json)"

          if [ "$HAS_REMOVED" = "true" ]; then
            BUMP="major"
          elif [ "$HAS_FEATURE" = "true" ]; then
            BUMP="minor"
          elif [ "$HAS_PATCH" = "true" ]; then
            BUMP="patch"
          else
            BUMP="patch"
          fi

          VER="${LAST#v}"
          MAJ="$(echo "$VER" | cut -d. -f1)"
          MIN="$(echo "$VER" | cut -d. -f2)"
          PAT="$(echo "$VER" | cut -d. -f3)"

          case "$BUMP" in
            major) MAJ=$((MAJ + 1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN + 1)); PAT=0 ;;
            patch) PAT=$((PAT + 1)) ;;
          esac

          BASE="v${MAJ}.${MIN}.${PAT}"

          LAST_N="$(git tag --list "${BASE}-stage.*" | sed 's/.*-stage\.//' | sort -n | tail -n 1 || true)"
          if [ -z "$LAST_N" ]; then
            NEXT_N=1
          else
            NEXT_N=$((LAST_N + 1))
          fi

          TAG="${BASE}-stage.${NEXT_N}"

          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "last_stable=$LAST" >> "$GITHUB_OUTPUT"
          echo "bump=$BUMP" >> "$GITHUB_OUTPUT"

          echo "Last stable: $LAST"
          echo "Bump: $BUMP"
          echo "Next prerelease tag: $TAG"

      - name: "Guard: skip if prerelease already exists"
        id: guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Prerelease $TAG already exists -> skipping."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Generate release notes (PR-based)
        if: steps.guard.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          PREV="${{ steps.meta.outputs.last_stable }}"

          if [ -z "$PREV" ] || [ "$PREV" = "v0.0.0" ]; then
            echo "No previous stable tag found -> generating notes without previous_tag_name"
            gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
              -f tag_name="$TAG" \
              --jq '.body' > RELEASE_NOTES.md
          else
            echo "Using previous stable tag: $PREV"
            gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
              -f tag_name="$TAG" \
              -f previous_tag_name="$PREV" \
              --jq '.body' > RELEASE_NOTES.md
          fi

          echo "## Pre-Release ${TAG} - $(date +%F)" | cat - RELEASE_NOTES.md > tmp && mv tmp RELEASE_NOTES.md

      - name: Create prerelease (draft)
        if: steps.guard.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.tag }}"
          gh release create "$TAG" \
            --title "Pre-Release $TAG" \
            --notes-file RELEASE_NOTES.md \
            --prerelease \
            --draft