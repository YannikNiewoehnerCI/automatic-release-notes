name: release-on-main

on:
  push:
    branches: ["main"]

permissions:
  contents: write
  pull-requests: read

jobs:
  release-notes-generation:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute next stable version from PR labels (SemVer)
        id: meta
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # 1️⃣ Find last stable tag
          LAST="$(git tag --list 'v*.*.*' --sort=-creatordate | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1 || true)"
          if [ -z "$LAST" ]; then
            LAST="v0.0.0"
          fi

          echo "Last stable tag: $LAST"

          # 2️⃣ Determine release window
          if [ "$LAST" = "v0.0.0" ]; then
            LAST_PUBLISHED_AT="1970-01-01T00:00:00Z"
          else
            LAST_PUBLISHED_AT="$(gh api "repos/${GITHUB_REPOSITORY}/releases/tags/${LAST}" --jq '.published_at' 2>/dev/null || true)"
            if [ -z "${LAST_PUBLISHED_AT:-}" ] || [ "${LAST_PUBLISHED_AT}" = "null" ]; then
              LAST_PUBLISHED_AT="$(git log -1 --format=%cI "${LAST}" || true)"
            fi
          fi

          echo "Collect PRs merged after: $LAST_PUBLISHED_AT"

          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"

          gh api graphql -f query='
            query($owner:String!, $name:String!) {
              repository(owner:$owner, name:$name) {
                pullRequests(first:100, states:MERGED, orderBy:{field:UPDATED_AT, direction:DESC}) {
                  nodes {
                    number
                    title
                    url
                    mergedAt
                    baseRefName
                    labels(first:50) { nodes { name } }
                  }
                }
              }
            }' -f owner="$OWNER" -f name="$REPO" > prs.json

          jq -c --arg since "$LAST_PUBLISHED_AT" '
            .data.repository.pullRequests.nodes
            | map(select(.baseRefName == "main"))
            | map(select(.mergedAt != null and .mergedAt > $since))
          ' prs.json > prs_since.json

          COUNT="$(jq 'length' prs_since.json)"
          echo "Merged PRs since last release: $COUNT"

          # 3️⃣ Determine bump level
          HAS_REMOVED="$(jq '[.[].labels.nodes[].name] | any(. == "removed")' prs_since.json)"
          HAS_FEATURE="$(jq '[.[].labels.nodes[].name] | any(. == "feature")' prs_since.json)"
          HAS_PATCH="$(jq '[.[].labels.nodes[].name] | any(. == "bug" or . == "security" or . == "documentation")' prs_since.json)"

          if [ "$HAS_REMOVED" = "true" ]; then
            BUMP="major"
          elif [ "$HAS_FEATURE" = "true" ]; then
            BUMP="minor"
          elif [ "$HAS_PATCH" = "true" ]; then
            BUMP="patch"
          else
            BUMP="patch"
          fi

          echo "Bump level: $BUMP"

          # 4️⃣ Bump version
          VER="${LAST#v}"
          MAJ="$(echo "$VER" | cut -d. -f1)"
          MIN="$(echo "$VER" | cut -d. -f2)"
          PAT="$(echo "$VER" | cut -d. -f3)"

          case "$BUMP" in
            major) MAJ=$((MAJ + 1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN + 1)); PAT=0 ;;
            patch) PAT=$((PAT + 1)) ;;
          esac

          NEXT="v${MAJ}.${MIN}.${PAT}"

          echo "Next stable tag: $NEXT"

          echo "last=$LAST" >> "$GITHUB_OUTPUT"
          echo "next=$NEXT" >> "$GITHUB_OUTPUT"
          echo "bump=$BUMP" >> "$GITHUB_OUTPUT"

      - name: "Guard: skip if stable release already exists"
        id: guard
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.next }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Release $TAG already exists -> skipping."
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create and push tag (idempotent)
        if: steps.guard.outputs.exists != 'true'
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.next }}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists locally."
          else
            git tag "$TAG"
            git push origin "$TAG"
          fi

      - name: Generate release notes (PR-based)
        if: steps.guard.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.next }}"
          PREV="${{ steps.meta.outputs.last }}"

          if [ -z "$PREV" ] || [ "$PREV" = "v0.0.0" ]; then
            echo "No previous stable tag found -> generating notes without previous_tag_name"
            gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
              -f tag_name="$TAG" \
              --jq '.body' > RELEASE_NOTES.md
          else
            echo "Using previous stable tag: $PREV"
            gh api -X POST "repos/${GITHUB_REPOSITORY}/releases/generate-notes" \
              -f tag_name="$TAG" \
              -f previous_tag_name="$PREV" \
              --jq '.body' > RELEASE_NOTES.md
          fi

          echo "## ${TAG} - $(date +%F)" | cat - RELEASE_NOTES.md > tmp && mv tmp RELEASE_NOTES.md

      - name: Create stable release
        if: steps.guard.outputs.exists != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.next }}"
          gh release create "$TAG" \
            --title "$TAG" \
            --notes-file RELEASE_NOTES.md

      - name: Upload artifact
        if: steps.guard.outputs.exists != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: release-notes
          path: RELEASE_NOTES.md